# Hexlet-course-tasks(composite_data)
6.2 Точки
points.js
Реализуйте и экспортируйте следующие функции для работы с точками:
quadrant - функция, которая вычисляет квадрант, в котором находится точка. Ниже приведена схема, показывающая номера квадрантов на плоскости.
       +
      2 | 1
        |
+----------------+
        |
      3 | 4
        +


const point = makePoint(1, 5);
quadrant(point); // 1
quadrant(makePoint(3, -3)); // 4


Если точка не принадлежит ни одному квадранту (т.е., если она лежит хотя бы на одной из осей координат), то функция должна возвращать null:
const point = makePoint(0, 7);
quadrant(point); // null
quadrant(makePoint(2, 0)); // null


symmetricalPoint - функция, возвращающая новую точку, симметричную относительно начала координат. Такая симметричность означает, что меняются знаки у x и y.
symmetricalPoint(makePoint(1, 5)); // makePoint(-1, -5)


distance - функция, вычисляющая расстояние между точками по формуле: d = sqrt((x2−x1)^2+(y2−y1)^2)
distance(makePoint(-2, -3), makePoint(-4, 4)); // ≈ 7.28


84% пользователей решило эту задачу самостоятельно

6.3 Пары
В этом задании мы немного потренируемся работать с парами. Без фанатизма и по шагам.
Шаг 1 - reversePair.js
Реализуйте функцию reversePair, которая принимает на вход пару и возвращает другую, в которой значения переставлены местами:
import { cons, car, cdr, toString } from 'hexlet-pairs';

const pair = cons('one', 'two');
console.log(toString(reversePair(pair))); // ('two', 'one')


Шаг 2 - sumOfPairs.js
Реализуйте функцию sumOfPairs, которая принимает на вход две пары и возвращает новую пару, в элементах которой находятся суммы элементов из исходных пар:
import { cons, car, cdr, toString } from 'hexlet-pairs';

const pair1 = cons(4, 10);
const pair2 = cons(100, 0);
console.log(toString(sumOfPairs(pair1, pair2))); // (104, 10)


Шаг 3 - findPrimitiveBox.js
Однажды вы сидели дома, когда курьер Василий принес вам коробку. С коробкой шла записка следующего содержания:
Коробка состоит из двух отсеков, в одном из которых письмо, а в другом лежит еще одна коробка, в которой также два отсека и точно также один отсек с письмом, а в другом - коробка. Коробки могут быть вложены друг в друга сколько угодно раз. Вам нужно добраться до коробки, внутри которой нет вложенной коробки ни в одном из двух отсеков, и отдать ее курьеру.
Подчеркну, что во всех коробках, кроме той последней, в одном отсеке письмо (любые данные, которые не являются парой), а в другом - всегда коробка, но никогда не две коробки одновременно. Сами отсеки при этом могут меняться, то есть в одной коробке отсеком с письмом может быть первый, а в другой - последний.
Реализуйте рекурсивную функцию findPrimitiveBox, которая принимает на вход "коробку" (пару), находит внутри нее пару без вложенных пар (как описано выше) и возвращает наружу.
import { cons, car, cdr, toString } from 'hexlet-pairs';

const pair = cons(
  null,
  cons('one', 'two'),
);
toString(findPrimitiveBox(pair)); // ('one', 'two')

const pair2 = cons(
  cons(null, cons(1, 5)),
  null,
);
toString(findPrimitiveBox(pair2)); // (1, 5)


Подсказки
Выполняйте практику строго по порядку (по шагам): от простых упражнений к более сложным.
Функция isPair из библиотеки hexlet-pairs проверяет, является ли переданный ей параметр парой. Более подробное описание функции смотрите в документации библиотеки (файл hexlet-pairs.md в каталоге docs).
Функцию toString из библиотеки hexlet-pairs можно использовать (при необходимости) для отладки решений.

82% пользователей решило эту задачу самостоятельно

6.4 Моделирование
Рассмотрим задачу представления отрезков на прямой плоскости. Каждый отрезок представляется как пара точек: начало и конец. Он может быть быть описан, например, так: [(1, 3), (5, 4)]. Это означает, что наш отрезок начинается в точке (1, 3) и заканчивается в точке (5, 4) координатной плоскости.
В этом задании необходимо разработать абстракцию для работы с отрезками (англ. сегмент), которая позволяет строить их из точек, извлекать из отрезков составные части (начало или конец сегмента), а также получать текстовое представление сегмента.
Абстракция заключается в том, что конкретное представление сегмента определяется внутри функций, описывающих работу с отрезками и зависит от создателя библиотеки. С точки зрения клиента библиотеки (кода который ее вызывает), не важно как конкретно устроен сегмент, важно только то, что есть некоторый набор функций (абстракция), позволяющий работать с ним.

segments.js
Определите и экспортируйте следующие функции:
Конструктор makeSegment, который принимает на вход две точки и возвращает сегмент. Первая точка это начало сегмента, вторая это конец.
Селекторы startSegment и endSegment, которые извлекают из сегмента его начальную и конечную точку соответственно.
Вспомогательную функцию segmentToString, которая возвращает текстовое представление сегмента: [(1, 2), (-4, -2)].
Функцию midpointSegment, которая находит точку на середине отрезка по формулaм: x = (x1 + x2) / 2 и y = (y1 + y2) / 2.
import * as points from 'hexlet-points';

// не важно, чем является segment с точки зрения реализации, главное, что с ним можно
// работать используя функции для работы с сегментами
const segment = makeSegment(points.makePoint(1, 2), points.makePoint(-4, -2));
console.log(toStr(segment)); // [(1, 2), (-4, -2)]

const point1 = startSegment(segment); // (1, 2)
console.log(points.toString(point1);

const point2 = endSegment(segment);
console.log(points.toString(point2)); // (-4, -2)

points.toString(startSegment(segment)) == points.toString(makePoint(1, 2)); // true

points.toString(midpointSegment(segment)); // (-1.5, 0)


Поскольку на текущий момент мы знакомы только с парами для работы с составными данными, то и реализация сегментов должна быть основана на них.

89% пользователей решило эту задачу самостоятельно

6.5 Барьеры абстракции
rectangles.js
Реализуйте абстракцию (набор функций) для работы с прямоугольниками, стороны которого всегда параллельны осям. При такой постановке, достаточно знать только три параметра для однозначного задания прямоугольника на плоскости: координаты левой-верхней точки, ширину и высоту. Зная их, мы всегда можем построить прямоугольник одним единственным способом.
 |
4 |    точка   ширина
  |       *-------------
3 |       |            |
  |       |            | высота
2 |       |            |
  |       --------------
1 |
  |
  |---------------------------
0    1   2   3   4   5   6   7


Основной интерфейс:
makeRectangle (конструктор) - создает прямоугольник. Принимает параметры: левую-верхнюю точку, ширину и высоту.
Селекторы startPoint, width и height
Вспомогательные функции для выполнения расчетов:
square - возвращает площадь прямоугольника (a * b).
perimeter - возвращает периметр прямоугольника (2 * (a + b)).
containsTheOrigin - проверяет, принадлежит ли центр координат прямоугольнику (не лежит на границе прямоугольника, а находится внутри). Чтобы в этом убедиться, достаточно проверить, что все точки прямоугольника лежат в разных квадрантах.
Так как это интерфейсные функции, то они должны быть экспортированы. Если этого не сделать, система модулей js не даст ими воспользоваться.
// Создание прямоугольника:
// p - левая верхняя точка
// 4 - ширина
// 5 - высота
//
// p    4
// -----------
// |         |
// |         | 5
// |         |
// -----------
const p = makePoint(0, 1);
const rectangle = makeRectangle(p, 4, 5);

// Вычисление площади прямоугольника
square(rectangle); // 20;

perimeter(rectangle); // 18
containsTheOrigin(rectangle); // false

const rectangle02 = makeRectangle(makePoint(-4, 3), 5, 4);
containsTheOrigin(rectangle02); // true

containsTheOrigin(makeRectangle(makePoint(-4, 4), 5, 2)); // false
containsTheOrigin(makeRectangle(makePoint(-4, 3), 2, 8)); // false


81% пользователей решило эту задачу самостоятельно


6.6 Реализация пар
Рассмотренный в уроке способ создания пар не является единственным возможным, даже если мы говорим только о реализации на функциях.
pairs.js
Напишите и экспортируйте функции car и cdr, основываясь на реализации функции cons:
const cons = (x, y) => f => f(x, y);


Подсказки
Все дело в хитрых функциях, которые вызывают другие функции и передают в них функции ;)
Задача проще, чем кажется. Каждая функция — это одна короткая строчка.

80% пользователей решило эту задачу самостоятельно

6.7 Рациональные числа
Рациональное число — число, представляемое обыкновенной дробью m/n, числитель m — целое число, а знаменатель n — натуральное число. Пример рационального числа: 2/3.
Формулы
Сложение
a/b + c/d = (a * d + b * c) / (b * d)


Вычитание
a/b - c/d = (a * d - b * c) / (b * d)


Умножение
a/b * c/d = (a * c) / (b * d)


Деление
a/b / c/d = (a * d) / (b * c)


Равенство
a/b = c/d, если a * d = c * b


rational.js
Реализуйте абстракцию для работы с рациональными числами, используя пары:
Конструктор make(numer, denom).
Селекторы numer (числитель) и denom (знаменатель).
Функцию toString, возвращающую строковое представление рационального числа. Например для дроби 3/4 созданной так make(3, 4), строковым представлением будет 3 / 4.
Предикат isEqual, проверяющую равенство двух рациональных чисел. Например isEqual(make(1, 2), make(2, 4)).
Функцию add, выполняющую сложение дробей.
Функцию sub, выполняющую вычитание дробей.
Функцию mul, выполняющую умножение дробей.
Функцию div, выполняющую деление дробей.
Экспортируйте созданные функции.
Обратите внимание, что результатом любой арифметической операции над рациональным числом будет рациональное число.
Пример:
const rat1 = make(2, 3);
const rat12 = make(4, 6);
const rat2 = make(7, 2);

toString(rat12); // '4 / 6'
isEqual(rat1, rat12); // true

add(rat1, rat2); // 25/6
sub(rat2, rat1); // 17/6
mul(rat1, rat2); // 14/6
div(rat1, rat2); // 4/21


86% пользователей решило эту задачу самостоятельно
