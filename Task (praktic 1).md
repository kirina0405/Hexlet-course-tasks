# Hexlet-course-tasks(praktic1)

ЗАДАЧИ из Введения в программирование
 
Задача 1. Инвертированный регистр
invertCase.js
Реализуйте и экспортируйте по умолчанию функцию invertCase, которая меняет в строке регистр каждой буквы на противоположный.
invertCase('Hello, World!') // hELLO, wORLD!
invertCase('I loVe JS') // i LOvE js
 
Задача 2. Без двух нулей (не решена!)
solution.js
Реализуйте и экспортируйте по умолчанию функцию, которая принимает на вход два аргумента - количество нулей и количество единиц, и определяет сколько есть способов размещения этих нулей и единиц так, что бы не было двух нулей идущих подряд.
Например, определим все способы размещения двух нулей и двух единиц. Существует шесть возможных способов размещения: 0011, 0101, 0110, 1001, 1010, 1100. В трех случаях содержится два нуля, идущих подряд: 0011, 1001 и 1100. Вычитаем их из общего числа и получаем три возможных способа: 0101, 0110 и 1010. Ответ - 3.
Примеры использования:
import withoutTwoZeros from './solution';

withoutTwoZeros(2, 2); // 3
withoutTwoZeros(1, 1); // 2
withoutTwoZeros(1, 3), // 4
withoutTwoZeros(2, 4); // 10

Задача 3. Сумма квадратов
sumSquareDifference.js
Сумма квадратов первых десяти натуральных чисел это 12 + 22 + 32 + ... + 10 2 = 385.
Квадрат суммы первых десяти натуральных чисел это (1 + 2 + 3 + ... + 10)2 = 552 = 3025.
Разница между квадратом суммы и суммой квадратов первых десяти натуральных чисел: 3025 − 385 = 2640.
Напишите функцию sumSquareDifference, которая принимает аргумент n и возвращает разницу между квадратом суммы и суммой квадратов первых n натуральных чисел.



Задача 4. Переворот строки
reverse.js
Реализуйте и экспортируйте функцию по умолчанию, которая переворачивает строку задом наперед, используя рекурсию.
Например:
import reverse from './reverse';


reverse('str'); // rts
reverse('hexlet'); // telxeh


Попробуйте решить эту задачу используя рекурсивный процесс. Для этого вам понадобится функция substr.
Подсказки
Чтобы узнать длину строки, используйте функцию length из модуля strings:
import { length } from './strings';


length('welcome'); // 7


Чтобы получить подстроку из строки, используйте функцию substr из модуля strings:
import { substr } from './strings';


substr('foo', 1, 2); // 'oo';


Задача 5. Найди Fizz и Buzz
fizzBuzz.js
Реализуйте и экспортируйте по умолчанию функцию, которая выводит (console.log) в терминал числа в диапазоне от begin до end. При этом, вывод происходит по следующим правилам:
Если число делится без остатка на 3 и на 5, то вместо числа выводится слово FizzBuzz
Если число делится без остатка на 5, то вместо него выводится слово Buzz
Если число делится без остатка на 3, то вместо него выводится слово Fizz
В остальных случаях выводится само число
Функция принимает два параметра (begin и end), определяющих ("включительно") начало и конец диапазона. Если диапазон пуст (в случае, когда begin > end), то функция просто ничего не печатает.
Пример
Вызов функции:
fizzBuzz(11, 20);


Вывод в терминале:
11
Fizz
13
14
FizzBuzz
16
17
Fizz
19
Buzz

Задача 6. Счастливые числа
Счастливые числа
Назовем счастливыми числами те, которые в результате ряда преобразований вида "сумма квадратов цифр" превратятся в единицу. Например:
7   => 7^2 = 49,
49  => 4^2 + 9^2 = 16 + 81 = 97,
97  => 9^2 + 7^2 = 81 + 49 = 130,
130 => 1^2 + 3^2 + 0^2 = 10,
10  => 1^2 + 0^2 = 1.


Вывод: исходное число 7 - счастливое.
isHappyNumber.js
Реализуйте и экспортируйте по умолчанию функцию, которая должна вернуть true, если число счастливое, и false, если нет. Количество итераций процесса поиска необходимо ограничить числом 10.
Подсказки
Воспользуйтесь вспомогательной функцией sumOfSquareDigits, которая принимает на вход число и возвращает "сумму квадратов цифр" этого числа.
 
ЗАДАЧА из “Функций”
Практика: Числа Черча
В 30-х годах прошлого века перед математиками встала так называемая проблема разрешения (Entscheidungsproblem), сформулированная Давидом Гильбертом. Суть её в том, что вот есть у нас некий формальный язык, на котором можно написать какое-либо утверждение. Существует ли алгоритм, за конечное число шагов определяющий его истинность или ложность? Ответ был найден двумя великими учёными того времени Алонзо Чёрчем и Аланом Тьюрингом. Они показали (первый — с помощью изобретённого им λ-исчисления, а второй — теории машины Тьюринга), что для арифметики такого алгоритма не существует в принципе, т.е. Entscheidungsproblem в общем случае неразрешима.
Так лямбда-исчисление впервые громко заявило о себе, но ещё пару десятков лет продолжало быть достоянием математической логики. Пока в середине 60-х Питер Ландин не отметил, что сложный язык программирования проще изучать, сформулировав его ядро в виде небольшого базового исчисления, выражающего самые существенные механизмы языка и дополненного набором удобных производных форм, поведение которых можно выразить путем перевода на язык базового исчисления. В качестве такой основы Ландин использовал лямбда-исчисление Чёрча. И всё заверте…
В основе лямбда-исчисления лежит понятие, известное ныне каждому программисту, — анонимная функция. В нём нет встроенных констант, элементарных операторов, чисел, арифметических операций, условных выражений, циклов и т. п. — только функции, только хардкор. Потому что лямбда-исчисление — это не язык программирования, а формальный аппарат, способный определить в своих терминах любую языковую конструкцию или алгоритм. В этом смысле оно созвучно машине Тьюринга, только соответствует функциональной парадигме, а не императивной.
Как уже говорилось ранее, в чистом бестиповом лямбда-исчислении отсутствует всё, кроме функций. Так что даже такие элементарные вещи, как числа или булевы значения необходимо реализовывать самим. Точнее, надо создать некие активные сущности, которые будут вести себя подобно необходимым нам объектам. И, естественно, процесс кодирования будет заключаться в написании соответствующих функций.
Натуральные числа реализованные посредством лямбда-исчисления, называются числами Черча, и являются отличной разминкой для мозга. В основе реализации по-прежнему будут лежать функции, ведущие себя в заданном контексте подобно единице, двойке и т.д. Собственно, это одна из особенностей лямбда-исчисления: сущности, записанные в его терминах, не обладают самодостаточностью, поскольку воплощают поведение того или иного объекта.
 
Источник
p.s. Вероятно, это задание не решить без чтения статей по лямбда-исчислению, но поверьте, оно того стоит.
numerals.js
Реализуйте число Zero и операцию Succ (увеличение на единицу). Не забудьте про экспорт.
Пример:
const two = Succ(Succ(Zero));


// Немного хитрый способ трансформировать число черча в обычное представление.
// Откровенно говоря, устройство самих чисел еще хитрее ;)
two(x => x + 1)(0); // 2



const four = Succ(Succ(two));
four(x => x + 1)(0); // 4
